var documenterSearchIndex = {"docs":
[{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Basics","page":"API Reference","title":"Basics","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Figgy.FigSource\nFiggy.load\nFiggy.NamedSource\nFiggy.ObjectSource\nFiggy.Fig\nFiggy.Store\nFiggy.load!\nFiggy.kmap\nFiggy.select","category":"page"},{"location":"reference/#Figgy.FigSource","page":"API Reference","title":"Figgy.FigSource","text":"Figgy.FigSource\n\nAbstract type for all concrete config subtypes. The interface for FigSource includes:     * T <: Figgy.FigSource: must subtype Figgy.FigSource     * Figgy.load(::T) -> key-value iterator: return a key-value iterator for config source T       Each \"key-value\" is an object x that can be indexed like: x[1] -> key and x[2] -> value       Examples include Pair, Tuple{K, V}, Vector of length 2, etc. Keys should be String type,       or will be converted to such via Figgy.load!. Values can be any type, though caution is advised       as many config sources only support loading String => String key-value pairs.       Figgy.load is called for each source when users call Figgy.load!(::Figgy.Store, sources...)       to retrieve the key-value config items to load in the store.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.load","page":"API Reference","title":"Figgy.load","text":"Figgy.load(::Figgy.FigSource) -> key-value iterator\n\nRequired function of the Figgy.FigSource interface. See the docs for Figgy.FigSource for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Figgy.NamedSource","page":"API Reference","title":"Figgy.NamedSource","text":"Figgy.NamedSource(name)\n\nA generic config source that has a name. Used when generic objects (Dict, Vector of Pairs) are passed to Figgy.load!, but a name can be provided for the specific set of configs.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.ObjectSource","page":"API Reference","title":"Figgy.ObjectSource","text":"Figgy.ObjectSource\n\nA generic, unnamed config source where key-value pairs are provided directly from an object, with no additional information to identify the config source.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.Fig","page":"API Reference","title":"Figgy.Fig","text":"Figgy.Fig(key, values, sources)\n\nRepresents a unique config item key and its history of values from various sources. Used by Figgy.Store to track config items.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.Store","page":"API Reference","title":"Figgy.Store","text":"Figgy.Store()\n\nA threadsafe config store. Tracks config item history as they are updated over time. Configs are loaded by calling Figgy.load!(::Figgy.Store, sources...), where sources is a list of Figgy.FigSource objects, including Figgy.ProgramArguments, Figgy.EnvironmentVariables, Figgy.IniFile, Figgy.JsonObject, Figgy.XmlObject, etc. Loading directly from Dict, NamedTuple, or Pair{String, String} is also allowed. See Figgy.load! for more details.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.load!","page":"API Reference","title":"Figgy.load!","text":"Figgy.load!(store::Store, sources...; name::String=\"\", log::Bool=true)\n\nLoad config items from sources into store. With in a single call to load!, it is assumed that sources are ordered by priority, with the highest priority source first. That means that if a config item is found, it will be ignored from any subsequent sources. The sources arguments can be any official Figgy.FigSource object, like Figgy.ProgramArguments, Figgy.EnvironmentVariables, Figgy.IniFile, Figgy.JsonObject, Figgy.XmlObject, etc. or a generic key-value-producer object, like Dict, NamedTuple, or Pair. For these generic objects, a name can be provided to identify the config source via the name keyword argument.\n\nNote: each call to Figgy.load! will gather all unique config items from sources and load them all, meaning config items already present in the store will be \"updated\" (though their history preserved).\n\nBy default, each config item loaded into the store is logged via an @info log message; to disable this logging, pass log=false.\n\nKeys for sources are expected to be String and will be converted to such if not already. Key uniqueness is then determined by exact string comparison (==).\n\nSee Figgy.kmap and Figgy.select for helper functions to transform key names or filter out keys prior to loading.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Figgy.select","page":"API Reference","title":"Figgy.select","text":"Figgy.select(source, keys)\n\nAllows filtering keys of a Figgy.FigSource object. Source is any official Figgy.FigSource object, or a generic key-value-producer object, like Dict, NamedTuple, or Pair. keys can be a one of the following:\n\na Function that takes a key and returns a Bool; applies to all keys in source\na Set of String keys that are the only keys to be included in the result\n\n\n\n\n\n","category":"function"},{"location":"reference/#Builtin-Configuration-Sources","page":"API Reference","title":"Builtin Configuration Sources","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Figgy.ProgramArguments\nFiggy.EnvironmentVariables\nFiggy.IniFile\nFiggy.JsonObject\nFiggy.XmlObject\nFiggy.TomlObject","category":"page"},{"location":"reference/#Figgy.ProgramArguments","page":"API Reference","title":"Figgy.ProgramArguments","text":"Figgy.ProgramArguments(requiredArgs...)\n\nA FigSource that parses command line arguments to a Julia program. Specifically, arguments of the following form are parsed:\n\n--key=value, long-form argument that is parsed as key => value\n-x, \"flag\" argument that is parsed as x => \"true\"\n-abc, multiple flag arguments that result in multiple key value pairs of the form a => \"true\", b => \"true\", c => \"true\"\n-x val, required argument that is parsed as x => val\n-xval, required argument that is parsed as x => \"val\" only when \"x\" is passed as a requiredArgs like ProgramArguments(\"x\")\n\nTo transform program argument keys, see Figgy.kmap.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.EnvironmentVariables","page":"API Reference","title":"Figgy.EnvironmentVariables","text":"Figgy.EnvironmentVariables()\n\nA FigSource that parses environment variables for config. Specifically, it takes the current contents of the ENV global variable for key-value pairs. Note that environment variable names will be preserved as-is; to transform/normalize the names, see Figgy.kmap.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.IniFile","page":"API Reference","title":"Figgy.IniFile","text":"Figgy.IniFile(file, section)\n\nA FigSource that parses an INI file. The file argument can be a path to the INI file, or a String that is the contents of the INI file. The section argument is required and specifies the INI file section that will be parsed for key-value pairs.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.JsonObject","page":"API Reference","title":"Figgy.JsonObject","text":"Figgy.JsonObject(json, path=\"\")\n\nA FigSource for parsing simple json as key-value pairs. The json argument must be a String which is itself json data, or a Vector{UInt8}. The json is expected to be a json object where the key-values will be considered key-value config pairs. The path argument is optional and is used to specify a nested path to an object that should be used for config pairs. So a json object like:\n\n{\n    \"k\": \"v\",\n    \"nested\": {\n        \"level2\": {\n            \"key1\": \"val1\",\n            \"key2\": \"val2\"\n        },\n        \"key3\": \"val3\"\n    }\n}\n\nWhere we wish to use the key-value pairs of nested.level2 for config, could be parsed like: Figgy.JsonObject(json, \"nested.level2\").\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.XmlObject","page":"API Reference","title":"Figgy.XmlObject","text":"Figgy.XmlObject(xml, path=\"\")\n\nA FigSource for parsing simple xml as key-value pairs. The xml argument must be a String which is itself xml data, or a Vector{UInt8}. The xml is expected to be a xml object where the key-values will be considered key-value config pairs. The path argument is optional and is used to specify a nested path to an object that should be used for config pairs. So a xml object like:\n\n<root>\n    <k>v</k>\n    <nested>\n        <level2>\n            <key1>val1</key1>\n            <key2>val2</key2>\n        </level2>\n        <key3>val3</key3>\n    </nested>\n</root>\n\nWhere we wish to use the key-value pairs of nested.level2 for config, could be parsed like: Figgy.XmlObject(xml, \"nested.level2\").\n\n\n\n\n\n","category":"type"},{"location":"reference/#Figgy.TomlObject","page":"API Reference","title":"Figgy.TomlObject","text":"Figgy.TomlObject(file, path=\"\")\n\nA FigSource for loading config key-value pairs from .toml files. The file argument can be a path to a .toml file, or a String of which the contents is toml data directly. The path argument is optional and is used to specify a nested path to an object that should be used for config pairs.\n\n\n\n\n\n","category":"type"},{"location":"#Figgy.jl-Documentation","page":"Home","title":"Figgy.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GitHub Repo: https://github.com/JuliaServices/Figgy.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to Figgy.jl! A threadsafe, sensible, configuration manager for Julia services.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install Figgy by typing the following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Figgy ","category":"page"},{"location":"","page":"Home","title":"Home","text":"followed by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Figgy","category":"page"},{"location":"","page":"Home","title":"Home","text":"to load the package.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Figgy.jl package provides a threadsafe configuration manager that allows respecting a priority of config sources and updating config values over time while tracking history. It offers support for a number of simple, builtin configuration source types with zero dependencies. The API is straightforward:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Figgy\nstore = Figgy.Store()\nFiggy.load!(store, sources...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, there must be a Figgy.Store object in which we store and track configuration key-value pairs. Then, via calls to Figgy.load!, we store config values, respecting the order in which various config sources are provided as the order of priority. For example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Figgy\nstore = Figgy.Store()\nFiggy.load!(store, Figgy.ProgramArguments(), Figgy.EnvironmentVariables())","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case, we're loading config key-value pairs from any program arguments and then environment variables. If we come across a key in the environment variables that was already seen in the program arguments, it will be ignored, placing priority/precedence on program arguments key since it was listed first. Alternatively, if we call:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Figgy\nstore = Figgy.Store()\nFiggy.load!(store, Figgy.ProgramArguments())\nFiggy.load!(store, Figgy.EnvironmentVariables())","category":"page"},{"location":"","page":"Home","title":"Home","text":"And again we have a matching key in environment variables, it will replace the value from program arguments since we're doing a separate load. This gives us the functionality where within a single load we can control which sources we prioritize, while also allowing us to update any config value later on by doing subsequent loads. This follows the common pattern seen in applications where on initialization, we want to do a prioritized load from a number of potential config sources, then later during normal runtime have the ability to tweak specific config values (like production log level) as needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API Reference page for the section on builtin configuration sources provided directly by Figgy.jl,  including program arguments, environment variales, ini files, json, xml, and toml.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the docs on Figgy.FigSource for the simple interface for creating your own custom config source.","category":"page"}]
}
